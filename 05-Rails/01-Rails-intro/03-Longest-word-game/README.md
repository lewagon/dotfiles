## Background & Objectives

Time to implement a "Longest-word game" with a cool web-interface! For some of you, it will seem familiar.

Before jumping into the exercise, [read the rules](https://github.com/lewagon/fullstack-challenges/tree/master/01-Ruby/06-Parsing/02-Numbers-and-Letters).

⛔️ If you worked on that exercise, please do not copy/paste solutions from previous exercises, try to rewrite them from scratch.

## Setup

There is no `rake` here, and do not create your Rails app in `fullstack-challenges`.

```bash
cd ~/code/<user.github_nickname>
rails new rails-longest-word-game --skip-active-storage --skip-action-mailbox
cd rails-longest-word-game
git add .
git commit -m "rails new"
gh repo create
git push origin master
```

## Specs

Let's think about the UI for our game. What do we need?

1. A page to display the game settings (random letters), with a form for the user to type a word. A button to submit this form.
2. A page receiving this form, computing the user score and displaying it.

### 1 - Routing & Controller

Using the right command line command, generate the `GamesController` with two actions `new` and `score`. The `new` action will be used to display a new random grid and a form. The form will be submitted (with `POST`) to the `score` action.

Open you `routes.rb` file and tweak the routes automatically generated by the previous command. In the end, `rails routes` should return something like this:

```bash
Prefix Verb URI Pattern      Controller#Action
   new GET  /new(.:format)   games#new
 score POST /score(.:format) games#score
```

### 2 - Generating a new game

Have a look at your old Ruby code. How did you generate an `Array` of random letters? In the `new` action of the `GamesController`, create a new `@letters` instance variable storing these random letters from the alphabet. Then display it in the view. You should get something like this:

![](https://raw.githubusercontent.com/lewagon/fullstack-images/master/rails/longest-word-game/new_game.png)

### 3 - Submitting a word

We need to add a form below the letters so that the user can fill a suggestion and submit it.

Go ahead and add a `<form />` to your view. It should `POST` to the `/score` action in the `GamesController`.

You will need to add the line below into your `form`:

```erb
<%= hidden_field_tag :authenticity_token, form_authenticity_token %>
```
This will add a hidden input field with an `authenticity_token` that ensures the `POST` request is coming from your website and not from another. Read [this stack overflow thread](https://stackoverflow.com/questions/941594/understanding-the-rails-authenticity-token) if you want to learn more about [CSRF](https://en.wikipedia.org/wiki/Cross-site_request_forgery) and why Rails adds this security layer by default!

![](https://raw.githubusercontent.com/lewagon/fullstack-images/master/rails/longest-word-game/new_game_with_form.png)

### 4 - At the other side of the form

Let's check that the form is being correctly set by inspecting what we get in `params`. They are two ways, the first one is to add `raise` in your controller code:

```ruby
# app/controllers/games_controller.rb

# [...]
  def score
    raise
  end
```

Go to the `/new` page, fill a word and submit the form. You should get a **RuntimeError** from Rails, with a console at the bottom. You can type `params` to inspect what got sent:

![](https://raw.githubusercontent.com/lewagon/fullstack-images/master/rails/longest-word-game/raise.png)

The cleaner way is to add the `pry-byebug` gem (you can get rid of the default `byebug` one from `rails new`) and add `binding.pry` in your Controller code. This way you can pause the Rails request in the terminal, inspect, and type `continue` to let it go and finish rendering the view.

```ruby
# Gemfile

# [...]
group :development, :test do
  # gem 'byebug', platforms: [:mri, :mingw, :x64_mingw]
  gem 'pry-byebug'
end
```

You need `bundle install` and restart `rails s` for this change to take effect.

### 5 - Computing the score

Time to implement the `GamesController#score` logic. Do we have all the information at hand? What do we need? Do we need to pass more information through the `POST` request? Have a look at [`hidden_field_tag`](http://api.rubyonrails.org/v5.1/classes/ActionView/Helpers/FormTagHelper.html#method-i-hidden_field_tag).

We want to handle three scenarios:

1. The word can't be built out of the original grid
2. The word is valid according to the grid, but is not a valid English word
3. The word is valid according to the grid and is an English word

(You can use [this API](https://wagon-dictionary.herokuapp.com/) to check if a word is valid.)

At the bottom of the results, add a `link_to` to go back to the New game page.

![](https://raw.githubusercontent.com/lewagon/fullstack-images/master/rails/longest-word-game/cant_be_built.png)

![](https://raw.githubusercontent.com/lewagon/fullstack-images/master/rails/longest-word-game/not_english_word.png)

![](https://raw.githubusercontent.com/lewagon/fullstack-images/master/rails/longest-word-game/congrats.png)

### 6 - Adding score (Optional)

The user will play many games, it makes sense to store each score and add it to a grand total. We can have a rule where the score for each game is the number of letters in every valid words (but you can be more creative, take the square of the number of letters? Something else?).

Today is not about the database, so we don't have ActiveRecord to help us store information and retrieve it between two HTTP requests. In Rails, another mechanisme exist to persist information **accross** HTTP requests: the [session](http://guides.rubyonrails.org/action_controller_overview.html#session).

Try to use a Rails session to store, compute and display a grand score.

### 7 - Testing (Optional)

First, delete the `test/controllers/games_controller_test.rb` file if it got generated. We will be doing [**System Testing**](http://guides.rubyonrails.org/testing.html#system-testing). The goal of this kind of testing is to automate all the manual testing of "code editing / go to the browser / reload the page / check if this is working". Everything you did manually in the browser can be done _via_ code!

First, you need to make sure you have a **recent** version of Chrome on your system (not Chromium). It's available for both OSX and Ubuntu. Then you need to install `chromedriver` (if you did this step in the previous exercise, just skip it):

```bash
 # macOS
brew cask install chromedriver

# Ubuntu
gem install chromedriver-helper
```

We will use _Headless Chrome_ for System Testing. It's a browser without a user interface, well-suited for this kind of automated tests. To do that, open the following file and replace **all** its content with:

```ruby
# test/application_system_test_case.rb
require "test_helper"

class ApplicationSystemTestCase < ActionDispatch::SystemTestCase
  Capybara.register_driver(:headless_chrome) do |app|
    capabilities = Selenium::WebDriver::Remote::Capabilities.chrome \
      chromeOptions: { args: %w[headless disable-gpu window-size=1280x760] }
    Capybara::Selenium::Driver.new app,
      browser: :chrome, desired_capabilities: capabilities
  end
  driven_by :headless_chrome
end
```

Ready? Let's dive into Rails Testing.

In the terminal, run the following to create the test file:

```bash
rails g system_test game
rails test:system # Should say 0 tests, and not fail
```

Great! We have a brand new file in ` test/system/games_test.rb`! What do we want to test?

1. Going to the `/new` game page displays a random grid
1. You can fill the form with a random word, click the play button, and get a message that the word is not in the grid.
1. You can fill the form with a one-letter consonant word, click play, and get a message it's not a valid English word
1. You can fill the form with a **valid** English word (that's hard because there is randomness!), click play and get a "Congratulations" message

Let's do the first one together:

```ruby
# test/system/games_test.rb
require "application_system_test_case"

class GamesTest < ApplicationSystemTestCase
  test "Going to /new gives us a new random grid to play with" do
    visit new_url
    assert test: "New game"
    assert_selector "li", count: 10
  end
end
```

In this test, I am visiting the `/new` URL and making sure I get ten letters to play with.

Now your turn! Try to implement the three other tests using Capybara `fill_in` and `click_on` methods.
